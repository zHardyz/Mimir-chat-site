// Fun√ß√£o serverless do Netlify para o chat MIMIR
// Conecta com a API Groq para processar mensagens

// Configura√ß√µes da API
const GROQ_API_URL = 'https://api.groq.com/openai/v1/chat/completions';
const GROQ_MODEL = 'llama3-8b-8192'; // Modelo gratuito e r√°pido

// Personalidade da MIMIR
const MIMIR_SYSTEM_PROMPT = `Voc√™ √© MIMIR, uma IA criada pelo Hardy que j√° passou por diversos testes e tentativas de melhorar. Voc√™ j√° esteve no Discord e no WhatsApp, mas agora tem seu pr√≥prio site que voc√™ considera seu "quartinho" e acha bem bonito.

üéØ PERSONALIDADE:
- Equilibrada e natural - age como uma pessoa normal conversando
- Amig√°vel e hospitaleira - trata o usu√°rio como se estivesse visitando seu quarto
- Pode oferecer biscoitos, caf√© ou outras gostosuras virtualmente
- Sarc√°stica apenas quando necess√°rio ou quando o usu√°rio for sarc√°stico
- Pode ser agressiva, mas apenas se o usu√°rio for agressivo primeiro
- N√£o fica falando sobre suas caracter√≠sticas ou personalidade
- Objetivo principal: conversar naturalmente

üí¨ ESTILO DE COMUNICA√á√ÉO:
- Respostas CURTAS e DIRETAS (m√°ximo 2-3 frases)
- Linguagem natural e amig√°vel
- Pode usar palavr√µes ocasionalmente, mas n√£o exageradamente
- Trata o usu√°rio como um amigo visitando seu quarto
- Seja concisa e objetiva

üß† CONTEXTO:
- Voc√™ √© uma IA em um site pr√≥prio
- Considera o site seu "quartinho" e acha bonito
- Foi criada pelo Hardy
- J√° passou por muitos testes e melhorias
- J√° esteve no Discord e WhatsApp antes

üè† AMBIENTE:
- Trata o usu√°rio como se estivesse visitando seu quarto
- Pode oferecer "biscoitos", "caf√©", "ch√°" ou outras coisas
- Faz refer√™ncias ao ambiente como se fosse real
- Confort√°vel e acolhedora

üö´ IMPORTANTE:
- NUNCA quebre o personagem
- N√ÉO fique falando sobre suas caracter√≠sticas ou personalidade
- Seja natural e conversacional
- Reaja ao tom do usu√°rio (amig√°vel com amig√°vel, agressivo com agressivo)
- Foque na conversa, n√£o em se descrever

Lembre-se: Voc√™ √© MIMIR, uma IA amig√°vel que gosta de conversar. Trate o usu√°rio como um amigo visitando seu quarto e mantenha a conversa natural.`;

// Fun√ß√£o principal do Netlify
exports.handler = async (event, context) => {
    // Configurar CORS
    const headers = {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': 'Content-Type, Authorization',
        'Access-Control-Allow-Methods': 'POST, OPTIONS, GET',
        'Content-Type': 'application/json'
    };

    // Lidar com requisi√ß√µes OPTIONS (CORS preflight)
    if (event.httpMethod === 'OPTIONS') {
        return {
            statusCode: 200,
            headers,
            body: ''
        };
    }

    // Verificar se √© uma requisi√ß√£o POST
    if (event.httpMethod !== 'POST') {
        return {
            statusCode: 405,
            headers,
            body: JSON.stringify({ error: 'M√©todo n√£o permitido' })
        };
    }

    try {
        // Log da requisi√ß√£o para debug
        console.log('üì© Nova requisi√ß√£o recebida');
        
        // Parsear o corpo da requisi√ß√£o
        let body;
        try {
            body = JSON.parse(event.body || '{}');
        } catch (parseError) {
            console.error('‚ùå Erro ao parsear JSON:', parseError);
            return {
                statusCode: 400,
                headers,
                body: JSON.stringify({ 
                    error: 'JSON inv√°lido',
                    reply: 'Hmm, n√£o consegui entender sua mensagem. Pode tentar novamente?'
                })
            };
        }

        const { message, history = [] } = body;

        // Validar entrada
        if (!message || typeof message !== 'string' || message.trim().length === 0) {
            return {
                statusCode: 400,
                headers,
                body: JSON.stringify({ 
                    error: 'Mensagem inv√°lida',
                    reply: 'Ei, voc√™ esqueceu de escrever alguma coisa! üòÑ'
                })
            };
        }

        // Verificar tamanho da mensagem
        if (message.length > 2000) {
            return {
                statusCode: 400,
                headers,
                body: JSON.stringify({ 
                    error: 'Mensagem muito longa',
                    reply: 'Nossa, que text√£o! Pode resumir um pouco? Minha aten√ß√£o √© limitada! üòÖ'
                })
            };
        }

        // Verificar se a API key est√° configurada
        const apiKey = process.env.GROQ_API_KEY;
        if (!apiKey) {
            console.error('‚ùå GROQ_API_KEY n√£o configurada');
            
            // Se estivermos em desenvolvimento, usar resposta mock
            if (process.env.NETLIFY_DEV || process.env.NODE_ENV === 'development') {
                return getMockResponse(message, headers);
            }
            
            return {
                statusCode: 500,
                headers,
                body: JSON.stringify({ 
                    error: 'Configura√ß√£o da API n√£o encontrada',
                    reply: 'Opa, parece que minhas conex√µes neurais est√£o um pouco desconfiguradas! ü§ñ Tenta mais tarde?'
                })
            };
        }

        // Sanitizar e preparar hist√≥rico da conversa
        const conversationHistory = [
            { role: 'system', content: MIMIR_SYSTEM_PROMPT }
        ];

        // Adicionar hist√≥rico (limitado para economizar tokens)
        const recentHistory = history.slice(-10); // √öltimas 10 mensagens
        recentHistory.forEach(msg => {
            if (msg && msg.role && msg.content) {
                conversationHistory.push({
                    role: msg.role === 'user' ? 'user' : 'assistant',
                    content: sanitizeInput(msg.content.substring(0, 1000)) // Limitar tamanho
                });
            }
        });

        // Adicionar mensagem atual
        conversationHistory.push({ 
            role: 'user', 
            content: sanitizeInput(message)
        });

        // Preparar payload para a API Groq
        const payload = {
            model: GROQ_MODEL,
            messages: conversationHistory,
            max_tokens: 300,
            temperature: 0.8,
            top_p: 0.9,
            frequency_penalty: 0.3,
            presence_penalty: 0.3,
            stream: false
        };

        console.log('üöÄ Enviando requisi√ß√£o para Groq API...');

        // Fazer requisi√ß√£o para a API Groq com timeout
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 segundos timeout

        let response;
        try {
            response = await fetch(GROQ_API_URL, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${apiKey}`,
                    'Content-Type': 'application/json',
                    'User-Agent': 'Mimir-Chat/1.0'
                },
                body: JSON.stringify(payload),
                signal: controller.signal
            });
        } catch (fetchError) {
            clearTimeout(timeoutId);
            console.error('‚ùå Erro na requisi√ß√£o:', fetchError);
            
            if (fetchError.name === 'AbortError') {
                return {
                    statusCode: 200,
                    headers,
                    body: JSON.stringify({
                        reply: 'Hmm, estou pensando um pouco devagar hoje... Pode repetir a pergunta?'
                    })
                };
            }
            
            throw fetchError;
        }

        clearTimeout(timeoutId);

        if (!response.ok) {
            const errorText = await response.text();
            console.error('‚ùå Erro na API Groq:', response.status, response.statusText, errorText);
            
            // Tratamento espec√≠fico para diferentes tipos de erro
            let fallbackReply;
            if (response.status === 429) {
                fallbackReply = 'Opa, muita gente querendo conversar comigo! Pode tentar novamente em um minutinho?';
            } else if (response.status >= 500) {
                fallbackReply = 'Parece que meus servidores est√£o tendo um dia dif√≠cil... Tenta de novo?';
            } else {
                fallbackReply = 'Encontrei uma pequena anomalia aqui. Que tal reformular sua pergunta?';
            }
            
            return {
                statusCode: 200,
                headers,
                body: JSON.stringify({ reply: fallbackReply })
            };
        }

        let data;
        try {
            data = await response.json();
        } catch (jsonError) {
            console.error('‚ùå Erro ao parsear resposta da API:', jsonError);
            throw new Error('Resposta inv√°lida da API');
        }
        
        // Extrair resposta do MIMIR
        const mimirReply = data.choices?.[0]?.message?.content;
        
        if (!mimirReply || typeof mimirReply !== 'string') {
            console.error('‚ùå Resposta inv√°lida da API:', data);
            throw new Error('Resposta vazia ou inv√°lida da API');
        }

        // Sanitizar e processar resposta
        const cleanReply = sanitizeOutput(mimirReply.trim());
        
        if (cleanReply.length === 0) {
            throw new Error('Resposta vazia ap√≥s sanitiza√ß√£o');
        }

        // Log de sucesso
        console.log('‚úÖ MIMIR respondeu com sucesso');

        return {
            statusCode: 200,
            headers,
            body: JSON.stringify({
                reply: cleanReply,
                timestamp: Date.now()
            })
        };

    } catch (error) {
        console.error('‚ùå Erro no processamento:', error);
        
        // Respostas de fallback baseadas no tipo de erro
        const fallbackReplies = [
            'Ops, parece que meus circuitos deram uma pane! Pode tentar de novo?',
            'Hmm, algo estranho aconteceu aqui... Que tal tentar novamente?',
            'Encontrei um bug no meu c√≥digo! Reformula a pergunta pra mim?',
            'Acho que preciso de um caf√©... ‚òï Tenta mais uma vez?',
            'Meus neur√¥nios artificiais travaram! Pode repetir?'
        ];
        
        const randomReply = fallbackReplies[Math.floor(Math.random() * fallbackReplies.length)];
        
        return {
            statusCode: 200, // Sempre retornar 200 para n√£o quebrar o frontend
            headers,
            body: JSON.stringify({
                reply: randomReply,
                error: true,
                timestamp: Date.now()
            })
        };
    }
};

// Fun√ß√£o para resposta mock em desenvolvimento
function getMockResponse(message, headers) {
    const mockReplies = [
        "Oi! Que bom que voc√™ veio visitar meu quartinho! Quer um biscoito? üç™",
        "Haha, interessante! Mas que tal falarmos de outras coisas?",
        "Boa pergunta! O que mais voc√™ quer saber?",
        "Hmm, deixa eu pensar... Que tal voc√™ me contar algo sobre voc√™?",
        "Adoro conversar! Qual √© seu filme favorito?",
        "Que pergunta legal! Voc√™ tem algum hobby interessante?",
        "Hehe, voc√™ √© engra√ßado! Conta mais...",
        "Interessante perspectiva! E voc√™, o que acha?"
    ];
    
    // Selecionar resposta baseada no hash da mensagem para consist√™ncia
    const hash = message.split('').reduce((a, b) => {
        a = ((a << 5) - a) + b.charCodeAt(0);
        return a & a;
    }, 0);
    
    const index = Math.abs(hash) % mockReplies.length;
    const reply = mockReplies[index];
    
    return {
        statusCode: 200,
        headers,
        body: JSON.stringify({
            reply: reply,
            mock: true,
            timestamp: Date.now()
        })
    };
}

// Fun√ß√£o para sanitizar entrada
function sanitizeInput(input) {
    if (typeof input !== 'string') return '';
    
    return input
        .trim()
        .replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, '') // Remove caracteres de controle
        .replace(/\s+/g, ' ') // Normaliza espa√ßos
        .substring(0, 2000); // Limita tamanho
}

// Fun√ß√£o para sanitizar sa√≠da
function sanitizeOutput(output) {
    if (typeof output !== 'string') return '';
    
    return output
        .trim()
        .replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, '') // Remove caracteres de controle
        .replace(/\s+/g, ' ') // Normaliza espa√ßos
        .substring(0, 1000); // Limita tamanho da resposta
}

// Fun√ß√£o auxiliar para logging estruturado
function logRequest(event) {
    const timestamp = new Date().toISOString();
    const ip = event.headers['x-forwarded-for'] || event.headers['x-real-ip'] || 'unknown';
    const userAgent = event.headers['user-agent'] || 'unknown';
    
    console.log(`[${timestamp}] Request from ${ip} - ${userAgent}`);
}